<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GemAI - Gemini Web App</title>
    <style>
        /* 2015年頃の端末でも開けるよう、シンプルなCSSを採用 */
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f0f0f0;
            color: #333;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        header {
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            text-align: center;
        }

        .tabs {
            display: flex;
            justify-content: space-around;
            background-color: #ddd;
            border-bottom: 1px solid #ccc;
        }

        .tab-button {
            flex-grow: 1;
            padding: 12px 0;
            cursor: pointer;
            text-align: center;
            border: none;
            background-color: transparent;
            font-size: 16px;
            color: #555;
            transition: background-color 0.2s;
        }

        .tab-button.active {
            background-color: white;
            color: #007bff;
            border-bottom: 3px solid #007bff;
        }

        .content {
            flex-grow: 1;
            padding: 20px;
            background-color: white;
            max-width: 800px;
            width: 100%;
            margin: 0 auto;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* フォーム要素のスタイリング */
        input[type="text"],
        textarea,
        button {
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-sizing: border-box;
            width: 100%;
        }

        button {
            background-color: #007bff;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover:not(:disabled) {
            background-color: #0056b3;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        /* 会話タブのスタイリング */
        #chat-window {
            height: 400px;
            overflow-y: auto;
            border: 1px solid #eee;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #f9f9f9;
        }

        .message {
            margin-bottom: 15px;
            padding: 8px 12px;
            border-radius: 15px;
            max-width: 80%;
            word-wrap: break-word;
        }

        .user-message {
            background-color: #d1e7ff;
            margin-left: auto;
            text-align: right;
        }

        .gemini-message {
            background-color: #e9ecef;
            margin-right: auto;
            text-align: left;
        }

        .message-actions {
            text-align: right;
            margin-top: 5px;
        }

        .action-button {
            background: none;
            border: none;
            color: #007bff;
            cursor: pointer;
            padding: 0 5px;
            width: auto;
            font-size: 12px;
            margin-left: 5px;
        }

        /* 履歴・Gemリストのスタイリング */
        .list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.1s;
        }

        .list-item:hover {
            background-color: #f0f0f0;
        }

        .list-item-name {
            flex-grow: 1;
        }

        .list-actions button {
            width: auto;
            padding: 5px 10px;
            margin-left: 5px;
            font-size: 12px;
            background-color: #dc3545;
        }

        .list-actions button.edit-button {
            background-color: #ffc107;
            color: #333;
        }

        .list-actions button:hover {
            background-color: #c82333;
        }

        /* その他 */
        .status-message {
            padding: 10px;
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
            margin-bottom: 10px;
            border-radius: 4px;
        }

        .error-message {
            background-color: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        #chat-header-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        #chat-name-input {
            width: calc(100% - 150px);
            display: inline;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

    <header>
        <h1>GemAI</h1>
    </header>

    <div class="tabs">
        <button class="tab-button active" onclick="switchTab('home')">ホーム</button>
        <button class="tab-button" onclick="switchTab('chat')">会話</button>
        <button class="tab-button" onclick="switchTab('history')">履歴</button>
        <button class="tab-button" onclick="switchTab('gem')">Gem</button>
        <button class="tab-button" onclick="switchTab('settings')">設定</button>
    </div>

    <main class="content">
        <!-- ホームタブ -->
        <div id="home-tab" class="tab-content active">
            <h2>新しい会話を開始</h2>
            <p>Gemini AIに質問を入力して、新しいチャットを始めましょう。</p>
            <textarea id="home-input" rows="4" placeholder="メッセージを入力..."></textarea>
            <button id="home-send-button">送信してチャット開始</button>
            <div id="home-gem-status" class="status-message hidden"></div>
        </div>

        <!-- 会話タブ -->
        <div id="chat-tab" class="tab-content">
            <div id="chat-header-actions">
                <input type="text" id="chat-name-input" placeholder="会話名" onchange="updateChatName()">
                <button onclick="deleteCurrentChat()" style="background-color: #dc3545;">会話を削除</button>
            </div>
            <div id="chat-window">
                <div class="status-message">「会話」タブでメッセージを送信するか、「履歴」タブから会話を開いてください。</div>
            </div>
            <textarea id="chat-input" rows="3" placeholder="メッセージを入力..." disabled></textarea>
            <button id="chat-send-button" disabled>送信</button>
        </div>

        <!-- 履歴タブ -->
        <div id="history-tab" class="tab-content">
            <h2>会話履歴</h2>
            <div id="history-list">
                <p>履歴がありません。</p>
            </div>
        </div>

        <!-- Gemタブ -->
        <div id="gem-tab" class="tab-content">
            <h2>カスタムGemの管理</h2>
            <div id="gem-form">
                <h3>Gemの新規作成 / 編集</h3>
                <input type="text" id="gem-id-input" class="hidden">
                <input type="text" id="gem-name-input" placeholder="Gem名 (例: 詩人Gem)">
                <textarea id="gem-instruction-input" rows="4" placeholder="システムインストラクション (例: あなたは情熱的な詩人です。すべての返答を詩として表現してください。)"></textarea>
                <button id="save-gem-button" onclick="saveGem()">Gemを保存</button>
            </div>

            <h3>作成済みGemリスト</h3>
            <div id="gem-list">
                <p>Gemがありません。</p>
            </div>
        </div>

        <!-- 設定タブ -->
        <div id="settings-tab" class="tab-content">
            <h2>設定</h2>

            <h3>Gemini APIキー</h3>
            <input type="text" id="api-key-input" placeholder="あなたのGemini APIキー">
            <button onclick="saveApiKey()">APIキーを保存</button>

            <h3>データ管理</h3>
            <button onclick="exportData()" style="background-color: #17a2b8;">チャット履歴・Gemをエクスポート</button>
            <p>エクスポートされたJSONファイルを読み込みます。</p>
            <input type="file" id="import-file-input" accept=".json">
            <button onclick="importData()" style="background-color: #28a745;">データをインポート</button>
            <div id="settings-status" class="status-message hidden"></div>
        </div>
    </main>

    <script>
        // グローバル変数
        let currentChatId = null;
        let currentGem = null; // 現在使用中のカスタムGem (systemInstructionを持つオブジェクト)
        const DB_NAME = 'GemAIDB';
        const DB_VERSION = 1;
        const STORE_CHATS = 'chats';
        const STORE_GEMS = 'gems';
        const STORE_SETTINGS = 'settings';
        const GEMINI_MODEL = 'gemini-2.5-flash-preview-09-2025';
        const API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL}:generateContent`;

        // ===============================================
        // 1. IndexedDB ラッパー関数
        // ===============================================

        /**
         * IndexedDBを開く
         * @returns {Promise<IDBDatabase>}
         */
        function openDB() {
            return new Promise((resolve, reject) => {
                if (!window.indexedDB) {
                    reject(new Error("IndexedDB not supported."));
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_CHATS)) {
                        db.createObjectStore(STORE_CHATS, { keyPath: 'chatId' });
                    }
                    if (!db.objectStoreNames.contains(STORE_GEMS)) {
                        db.createObjectStore(STORE_GEMS, { keyPath: 'gemId' });
                    }
                    if (!db.objectStoreNames.contains(STORE_SETTINGS)) {
                        db.createObjectStore(STORE_SETTINGS, { keyPath: 'key' });
                    }
                };

                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };

                request.onerror = (event) => {
                    console.error("IndexedDB error:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        /**
         * データをIndexedDBに保存する
         * @param {string} storeName - ストア名
         * @param {Object} data - 保存するデータ
         * @returns {Promise<void>}
         */
        async function putData(storeName, data) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.put(data);

                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error('Put error:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        /**
         * データをIndexedDBから取得する
         * @param {string} storeName - ストア名
         * @param {string} key - キー
         * @returns {Promise<Object>}
         */
        async function getData(storeName, key) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.get(key);

                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => {
                    console.error('Get error:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        /**
         * ストア内のすべてのデータを取得する
         * @param {string} storeName - ストア名
         * @returns {Promise<Array<Object>>}
         */
        async function getAllData(storeName) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readonly');
                const store = transaction.objectStore(storeName);
                const request = store.getAll();

                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => {
                    console.error('GetAll error:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        /**
         * データをIndexedDBから削除する
         * @param {string} storeName - ストア名
         * @param {string} key - キー
         * @returns {Promise<void>}
         */
        async function deleteData(storeName, key) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([storeName], 'readwrite');
                const store = transaction.objectStore(storeName);
                const request = store.delete(key);

                request.onsuccess = () => resolve();
                request.onerror = (event) => {
                    console.error('Delete error:', event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // ===============================================
        // 2. アプリケーションロジック
        // ===============================================

        /**
         * タブを切り替える
         * @param {string} tabId - 切り替えるタブのID (home, chat, history, gem, settings)
         */
        async function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab-button').forEach(el => el.classList.remove('active'));

            document.getElementById(`${tabId}-tab`).classList.add('active');
            document.querySelector(`.tab-button[onclick*='${tabId}']`).classList.add('active');

            // タブごとに必要な初期化/更新処理を呼び出す
            if (tabId === 'history') {
                await renderHistoryList();
            } else if (tabId === 'gem') {
                await renderGemList();
            } else if (tabId === 'settings') {
                await loadApiKey();
            } else if (tabId === 'chat') {
                if (!currentChatId) {
                    // チャットが開かれていない場合、チャットウィンドウをリセット
                    document.getElementById('chat-window').innerHTML = '<div class="status-message">「会話」タブでメッセージを送信するか、「履歴」タブから会話を開いてください。</div>';
                    document.getElementById('chat-name-input').value = '';
                    document.getElementById('chat-input').disabled = true;
                    document.getElementById('chat-send-button').disabled = true;
                }
            }
        }

        /**
         * メッセージ送信ボタンのイベントリスナー設定
         */
        document.getElementById('home-send-button').addEventListener('click', () => {
            const input = document.getElementById('home-input').value.trim();
            if (input) {
                startNewChat(input);
            }
        });

        document.getElementById('chat-send-button').addEventListener('click', () => {
            const input = document.getElementById('chat-input').value.trim();
            if (input) {
                sendMessage(input);
            }
        });

        document.getElementById('chat-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                document.getElementById('chat-send-button').click();
            }
        });
        
        document.getElementById('home-input').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                document.getElementById('home-send-button').click();
            }
        });

        // ===============================================
        // 3. APIキーと設定
        // ===============================================

        /**
         * APIキーをIndexedDBに保存する
         */
        async function saveApiKey() {
            const apiKey = document.getElementById('api-key-input').value.trim();
            const statusEl = document.getElementById('settings-status');
            try {
                await putData(STORE_SETTINGS, { key: 'apiKey', value: apiKey });
                statusEl.textContent = 'APIキーを保存しました。';
                statusEl.classList.remove('error-message', 'hidden');
                console.log('API Key saved.');
            } catch (error) {
                statusEl.textContent = `APIキーの保存に失敗しました: ${error.message}`;
                statusEl.classList.add('error-message');
                statusEl.classList.remove('hidden');
                console.error(error);
            }
        }

        /**
         * IndexedDBからAPIキーを読み込み、設定タブに表示する
         */
        async function loadApiKey() {
            try {
                const data = await getData(STORE_SETTINGS, 'apiKey');
                if (data) {
                    document.getElementById('api-key-input').value = data.value;
                }
            } catch (error) {
                console.error('Failed to load API key:', error);
            }
        }

        /**
         * APIキーをIndexedDBから取得する
         * @returns {Promise<string>}
         */
        async function getApiKey() {
            try {
                const data = await getData(STORE_SETTINGS, 'apiKey');
                return data ? data.value : '';
            } catch (error) {
                console.error('Error fetching API key:', error);
                return '';
            }
        }


        // ===============================================
        // 4. Gemini API通信
        // ===============================================

        /**
         * Gemini APIを呼び出す
         * @param {Array<Object>} history - 過去の会話履歴 (contents形式)
         * @param {Object|null} gem - 使用するGem (systemInstruction)
         * @returns {Promise<string>} - Geminiの返答テキスト
         */
        async function callGemini(history, gem) {
            const apiKey = await getApiKey();
            if (!apiKey) {
                throw new Error("APIキーが設定されていません。「設定」タブで入力・保存してください。");
            }

            // 最後の要素をユーザープロンプトとして使用し、それ以前を履歴として使用
            const userQuery = history[history.length - 1].parts[0].text;
            const chatHistory = history.slice(0, history.length - 1);

            const systemInstruction = gem ? gem.systemInstruction : undefined;

            const payload = {
                contents: history,
                systemInstruction: systemInstruction ? { parts: [{ text: systemInstruction }] } : undefined,
            };

            const MAX_RETRIES = 5;
            for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
                try {
                    const response = await fetch(`${API_URL}?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorBody = await response.text();
                        throw new Error(`APIリクエストが失敗しました。ステータス: ${response.status}, 詳細: ${errorBody}`);
                    }

                    const result = await response.json();
                    const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (!text) {
                        throw new Error("AIからの返答が空です。プロンプトを見直すか、Gemini APIキーを確認してください。");
                    }
                    return text;

                } catch (error) {
                    if (attempt < MAX_RETRIES - 1) {
                        const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                        console.warn(`API呼び出し失敗 (試行 ${attempt + 1}/${MAX_RETRIES})。${(delay / 1000).toFixed(1)}秒後に再試行します...`, error);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        throw error;
                    }
                }
            }
        }

        // ===============================================
        // 5. 会話 (チャット) ロジック
        // ===============================================

        /**
         * 新しいチャットを開始し、最初のメッセージを送信する
         * @param {string} initialMessage - 最初のメッセージ
         * @param {string|null} gemId - 使用するGemのID (ホームからの開始時のみnull)
         */
        async function startNewChat(initialMessage, gemId = null) {
            currentChatId = crypto.randomUUID();
            currentGem = null;
            let chatName = initialMessage.substring(0, 30) + (initialMessage.length > 30 ? '...' : '');
            let gemStatusText = '通常チャット';

            if (gemId) {
                const gem = await getData(STORE_GEMS, gemId);
                if (gem) {
                    currentGem = gem;
                    chatName = `[${gem.name}] ${chatName}`;
                    gemStatusText = `Gem使用: ${gem.name}`;
                }
            }

            const newChat = {
                chatId: currentChatId,
                name: chatName,
                messages: [{ role: 'user', parts: [{ text: initialMessage }] }],
                timestamp: Date.now(),
                gemId: gemId,
            };

            await putData(STORE_CHATS, newChat);

            // UI更新
            switchTab('chat');
            document.getElementById('home-input').value = '';
            document.getElementById('home-gem-status').classList.add('hidden');
            document.getElementById('chat-name-input').value = newChat.name;
            document.getElementById('chat-window').innerHTML = '';
            document.getElementById('chat-input').disabled = false;
            document.getElementById('chat-send-button').disabled = false;

            // 最初のメッセージをUIに追加
            displayMessage({ role: 'user', parts: [{ text: initialMessage }] });

            // AI応答を取得
            const chatInputEl = document.getElementById('chat-input');
            const chatSendBtn = document.getElementById('chat-send-button');

            chatInputEl.disabled = true;
            chatSendBtn.disabled = true;
            displayLoadingMessage();

            try {
                const geminiText = await callGemini(newChat.messages, currentGem);
                
                // ローディングメッセージを削除し、AI応答を表示
                removeLoadingMessage();
                displayMessage({ role: 'model', parts: [{ text: geminiText }] });

                // 履歴を更新
                newChat.messages.push({ role: 'model', parts: [{ text: geminiText }] });
                await putData(STORE_CHATS, newChat);

            } catch (error) {
                removeLoadingMessage();
                displayErrorMessage(error.message);
                console.error(error);
            } finally {
                chatInputEl.disabled = false;
                chatSendBtn.disabled = false;
                chatInputEl.focus();
            }
        }

        /**
         * 既存の会話を開く
         * @param {string} chatId - 開く会話のID
         */
        async function openChat(chatId) {
            currentChatId = chatId;
            currentGem = null;
            switchTab('chat');

            try {
                const chat = await getData(STORE_CHATS, chatId);
                if (!chat) throw new Error('会話が見つかりません。');

                document.getElementById('chat-name-input').value = chat.name;
                document.getElementById('chat-window').innerHTML = '';
                document.getElementById('chat-input').disabled = false;
                document.getElementById('chat-send-button').disabled = false;

                // Gemが使用されている場合は設定
                if (chat.gemId) {
                    const gem = await getData(STORE_GEMS, chat.gemId);
                    if (gem) currentGem = gem;
                }

                // メッセージ表示
                chat.messages.forEach(displayMessage);

                // スクロールを一番下へ
                const chatWindow = document.getElementById('chat-window');
                chatWindow.scrollTop = chatWindow.scrollHeight;

            } catch (error) {
                displayErrorMessage(`会話を開けませんでした: ${error.message}`);
                currentChatId = null;
            }
        }

        /**
         * 現在のチャットにメッセージを送信し、応答を取得・表示する
         * @param {string} message - ユーザーメッセージ
         */
        async function sendMessage(message) {
            if (!currentChatId) return;

            const chatInputEl = document.getElementById('chat-input');
            const chatSendBtn = document.getElementById('chat-send-button');

            // UIを無効化
            chatInputEl.value = '';
            chatInputEl.disabled = true;
            chatSendBtn.disabled = true;

            // メッセージをUIに追加
            const userMessage = { role: 'user', parts: [{ text: message }] };
            displayMessage(userMessage);
            displayLoadingMessage();

            try {
                const chat = await getData(STORE_CHATS, currentChatId);
                if (!chat) throw new Error('現在の会話データが見つかりません。');
                
                // 履歴にユーザーメッセージを追加 (APIに送信するため)
                chat.messages.push(userMessage);

                // AI応答を取得
                const geminiText = await callGemini(chat.messages, currentGem);

                // ローディングメッセージを削除し、AI応答を表示
                removeLoadingMessage();
                const geminiMessage = { role: 'model', parts: [{ text: geminiText }] };
                displayMessage(geminiMessage);

                // 履歴を更新
                chat.messages.push(geminiMessage);
                await putData(STORE_CHATS, chat);

            } catch (error) {
                removeLoadingMessage();
                displayErrorMessage(error.message);
                console.error(error);
            } finally {
                chatInputEl.disabled = false;
                chatSendBtn.disabled = false;
                chatInputEl.focus();
            }
        }

        /**
         * チャット名が変更されたときにIndexedDBを更新する
         */
        async function updateChatName() {
            if (!currentChatId) return;
            const newName = document.getElementById('chat-name-input').value.trim();
            if (!newName) return;

            try {
                const chat = await getData(STORE_CHATS, currentChatId);
                if (chat) {
                    chat.name = newName;
                    await putData(STORE_CHATS, chat);
                    // 履歴リストの更新が必要だが、ここではシンプルにコンソールにログ
                    console.log(`Chat ${currentChatId} name updated to: ${newName}`);
                }
            } catch (error) {
                console.error('Failed to update chat name:', error);
            }
        }

        /**
         * 現在開いているチャットを削除する
         */
        async function deleteCurrentChat() {
            if (!currentChatId) return;

            if (!window.confirm("この会話を完全に削除してもよろしいですか？")) return;

            try {
                await deleteData(STORE_CHATS, currentChatId);
                currentChatId = null;
                currentGem = null;
                switchTab('history'); // 履歴タブに移動
                console.log('Chat deleted.');
            } catch (error) {
                console.error('Failed to delete chat:', error);
                alert('会話の削除に失敗しました。');
            }
        }

        // ===============================================
        // 6. UI レンダリング (チャット)
        // ===============================================

        /**
         * メッセージをチャットウィンドウに表示する
         * @param {Object} message - { role: 'user'|'model', parts: [{ text: string }] }
         */
        function displayMessage(message) {
            const chatWindow = document.getElementById('chat-window');
            const messageEl = document.createElement('div');
            messageEl.classList.add('message');
            messageEl.classList.add(message.role === 'user' ? 'user-message' : 'gemini-message');

            const text = message.parts[0].text.replace(/\n/g, '<br>');
            const textContent = document.createElement('div');
            textContent.innerHTML = text;
            messageEl.appendChild(textContent);

            if (message.role === 'model') {
                const actions = document.createElement('div');
                actions.classList.add('message-actions');

                // コピーボタン
                const copyBtn = document.createElement('button');
                copyBtn.classList.add('action-button');
                copyBtn.textContent = 'コピー';
                copyBtn.onclick = () => copyToClipboard(message.parts[0].text, copyBtn);
                actions.appendChild(copyBtn);

                // 共有ボタン (簡易的な機能、ここではテキストをコピー)
                const shareBtn = document.createElement('button');
                shareBtn.classList.add('action-button');
                shareBtn.textContent = '共有 (コピー)';
                shareBtn.onclick = () => copyToClipboard(message.parts[0].text, shareBtn);
                actions.appendChild(shareBtn);

                messageEl.appendChild(actions);
            }

            chatWindow.appendChild(messageEl);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        /**
         * ローディングメッセージ (Geminiからの応答待ち) を表示する
         */
        function displayLoadingMessage() {
            const chatWindow = document.getElementById('chat-window');
            const loadingEl = document.createElement('div');
            loadingEl.id = 'loading-message';
            loadingEl.classList.add('gemini-message', 'message');
            loadingEl.textContent = 'AIが応答中...';
            chatWindow.appendChild(loadingEl);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        /**
         * ローディングメッセージを削除する
         */
        function removeLoadingMessage() {
            const loadingEl = document.getElementById('loading-message');
            if (loadingEl) {
                loadingEl.remove();
            }
        }

        /**
         * エラーメッセージをチャットウィンドウに表示する
         * @param {string} message - エラーメッセージ
         */
        function displayErrorMessage(message) {
            const chatWindow = document.getElementById('chat-window');
            const errorEl = document.createElement('div');
            errorEl.classList.add('status-message', 'error-message');
            errorEl.innerHTML = `<strong>エラー:</strong> ${message}`;
            chatWindow.appendChild(errorEl);
            chatWindow.scrollTop = chatWindow.scrollHeight;
        }

        /**
         * テキストをクリップボードにコピーする
         * @param {string} text - コピーするテキスト
         * @param {HTMLElement} buttonEl - クリックされたボタン要素
         */
        function copyToClipboard(text, buttonEl) {
            const tempTextarea = document.createElement('textarea');
            tempTextarea.value = text;
            document.body.appendChild(tempTextarea);
            tempTextarea.select();
            
            try {
                // document.execCommand('copy') は古いブラウザでも動作する代替手段
                const successful = document.execCommand('copy');
                const originalText = buttonEl.textContent;
                buttonEl.textContent = successful ? 'コピーしました！' : 'コピー失敗';

                setTimeout(() => {
                    buttonEl.textContent = originalText;
                }, 2000);
            } catch (err) {
                console.error('Copy failed:', err);
                buttonEl.textContent = 'コピー失敗';
            }
            
            document.body.removeChild(tempTextarea);
        }

        // ===============================================
        // 7. 履歴タブのロジック
        // ===============================================

        /**
         * 履歴リストをレンダリングする
         */
        async function renderHistoryList() {
            const listEl = document.getElementById('history-list');
            listEl.innerHTML = '';
            try {
                const chats = await getAllData(STORE_CHATS);
                if (chats.length === 0) {
                    listEl.innerHTML = '<p>履歴がありません。</p>';
                    return;
                }

                // タイムスタンプで降順ソート
                chats.sort((a, b) => b.timestamp - a.timestamp);

                chats.forEach(chat => {
                    const itemEl = document.createElement('div');
                    itemEl.classList.add('list-item');
                    itemEl.onclick = () => openChat(chat.chatId);

                    const nameEl = document.createElement('span');
                    const gemTag = chat.gemId ? ` <small style="color:#007bff;">[Gem使用]</small>` : '';
                    nameEl.innerHTML = `${chat.name}${gemTag}`;
                    nameEl.classList.add('list-item-name');

                    const timestampEl = document.createElement('small');
                    timestampEl.textContent = new Date(chat.timestamp).toLocaleString();
                    timestampEl.style.marginLeft = '10px';
                    
                    const actionsEl = document.createElement('div');
                    actionsEl.classList.add('list-actions');

                    // 削除ボタン
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = '削除';
                    deleteBtn.style.backgroundColor = '#dc3545';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation(); // 親要素のopenChatを防止
                        deleteChat(chat.chatId);
                    };
                    actionsEl.appendChild(deleteBtn);

                    itemEl.appendChild(nameEl);
                    itemEl.appendChild(timestampEl);
                    itemEl.appendChild(actionsEl);
                    listEl.appendChild(itemEl);
                });
            } catch (error) {
                listEl.innerHTML = `<p class="error-message">履歴の読み込みに失敗しました: ${error.message}</p>`;
                console.error('Failed to render history:', error);
            }
        }

        /**
         * 指定されたチャットを削除する
         * @param {string} chatId - 削除するチャットのID
         */
        async function deleteChat(chatId) {
            if (!window.confirm("この会話を完全に削除してもよろしいですか？")) return;

            try {
                await deleteData(STORE_CHATS, chatId);
                await renderHistoryList(); // リストを再レンダリング
                console.log(`Chat ${chatId} deleted.`);
            } catch (error) {
                console.error('Failed to delete chat:', error);
                alert('会話の削除に失敗しました。');
            }
        }

        // ===============================================
        // 8. Gemタブのロジック
        // ===============================================

        /**
         * Gemを保存・更新する
         */
        async function saveGem() {
            const id = document.getElementById('gem-id-input').value.trim();
            const name = document.getElementById('gem-name-input').value.trim();
            const instruction = document.getElementById('gem-instruction-input').value.trim();

            if (!name || !instruction) {
                alert('Gem名とインストラクションは必須です。');
                return;
            }

            const gem = {
                gemId: id || crypto.randomUUID(),
                name: name,
                systemInstruction: instruction
            };

            try {
                await putData(STORE_GEMS, gem);
                
                // フォームをリセット
                document.getElementById('gem-id-input').value = '';
                document.getElementById('gem-name-input').value = '';
                document.getElementById('gem-instruction-input').value = '';
                document.getElementById('save-gem-button').textContent = 'Gemを保存';

                await renderGemList();
                alert(`Gem「${name}」を保存しました。`);
            } catch (error) {
                console.error('Failed to save Gem:', error);
                alert('Gemの保存に失敗しました。');
            }
        }

        /**
         * Gemリストをレンダリングする
         */
        async function renderGemList() {
            const listEl = document.getElementById('gem-list');
            listEl.innerHTML = '';
            try {
                const gems = await getAllData(STORE_GEMS);
                if (gems.length === 0) {
                    listEl.innerHTML = '<p>Gemがありません。新しいGemを作成しましょう。</p>';
                    return;
                }

                gems.forEach(gem => {
                    const itemEl = document.createElement('div');
                    itemEl.classList.add('list-item');

                    const nameEl = document.createElement('span');
                    nameEl.innerHTML = `<strong>${gem.name}</strong>`;
                    nameEl.classList.add('list-item-name');
                    nameEl.onclick = () => selectGemForHome(gem); // クリックでホームに設定

                    const actionsEl = document.createElement('div');
                    actionsEl.classList.add('list-actions');

                    // 編集ボタン
                    const editBtn = document.createElement('button');
                    editBtn.textContent = '編集';
                    editBtn.classList.add('edit-button');
                    editBtn.onclick = (e) => {
                        e.stopPropagation();
                        editGem(gem);
                    };
                    actionsEl.appendChild(editBtn);

                    // 削除ボタン
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = '削除';
                    deleteBtn.style.backgroundColor = '#dc3545';
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        deleteGem(gem.gemId, gem.name);
                    };
                    actionsEl.appendChild(deleteBtn);

                    itemEl.appendChild(nameEl);
                    itemEl.appendChild(actionsEl);
                    listEl.appendChild(itemEl);
                });
            } catch (error) {
                listEl.innerHTML = `<p class="error-message">Gemの読み込みに失敗しました: ${error.message}</p>`;
                console.error('Failed to render Gem list:', error);
            }
        }

        /**
         * Gemを編集フォームにロードする
         * @param {Object} gem - 編集するGemオブジェクト
         */
        function editGem(gem) {
            document.getElementById('gem-id-input').value = gem.gemId;
            document.getElementById('gem-name-input').value = gem.name;
            document.getElementById('gem-instruction-input').value = gem.systemInstruction;
            document.getElementById('save-gem-button').textContent = 'Gemを更新';
            alert(`Gem「${gem.name}」を編集モードで開きました。`);
            switchTab('gem');
        }

        /**
         * Gemを削除する
         * @param {string} gemId - 削除するGemのID
         * @param {string} gemName - 削除するGemの名前
         */
        async function deleteGem(gemId, gemName) {
            if (!window.confirm(`Gem「${gemName}」を本当に削除してもよろしいですか？`)) return;

            try {
                await deleteData(STORE_GEMS, gemId);
                await renderGemList();
                alert(`Gem「${gemName}」を削除しました。`);
                console.log(`Gem ${gemId} deleted.`);
            } catch (error) {
                console.error('Failed to delete Gem:', error);
                alert('Gemの削除に失敗しました。');
            }
        }

        /**
         * Gemをホームタブに設定し、新しいチャットを開始できるようにする
         * @param {Object} gem - 選択されたGemオブジェクト
         */
        function selectGemForHome(gem) {
            currentGem = gem;
            document.getElementById('home-gem-status').textContent = `現在、Gem「${gem.name}」を使用中。メッセージを送信すると、このGemとの会話が始まります。`;
            document.getElementById('home-gem-status').classList.remove('hidden', 'error-message');

            // ホームタブに移動
            switchTab('home');

            // ホーム送信ボタンのイベントリスナーを一時的に変更
            document.getElementById('home-send-button').removeEventListener('click', homeSendButtonHandler);
            document.getElementById('home-send-button').addEventListener('click', homeSendButtonHandlerWithGem, { once: true });
        }
        
        // Gem使用時と未使用時で処理を分けるためのハンドラ
        const homeSendButtonHandler = () => {
            const input = document.getElementById('home-input').value.trim();
            if (input) {
                startNewChat(input);
            }
        };

        const homeSendButtonHandlerWithGem = () => {
            const input = document.getElementById('home-input').value.trim();
            if (input && currentGem) {
                // GemIdを渡してチャット開始
                startNewChat(input, currentGem.gemId);
            } else {
                 // Gemが設定されていない場合、通常のハンドラを再設定
                document.getElementById('home-send-button').removeEventListener('click', homeSendButtonHandlerWithGem);
                document.getElementById('home-send-button').addEventListener('click', homeSendButtonHandler);
            }
        };
        // 初期設定
        document.getElementById('home-send-button').addEventListener('click', homeSendButtonHandler);

        // ===============================================
        // 9. エクスポート・インポート
        // ===============================================

        /**
         * 全てのデータ (チャットとGem) をJSON形式でエクスポートする
         */
        async function exportData() {
            const statusEl = document.getElementById('settings-status');
            statusEl.classList.add('hidden');
            try {
                const chats = await getAllData(STORE_CHATS);
                const gems = await getAllData(STORE_GEMS);

                const exportData = {
                    metadata: {
                        app: 'GemAI',
                        version: DB_VERSION,
                        exportDate: new Date().toISOString()
                    },
                    chats: chats,
                    gems: gems
                };

                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `GemAI_export_${new Date().toISOString().slice(0, 10)}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                statusEl.textContent = 'データのエクスポートが完了しました。';
                statusEl.classList.remove('error-message', 'hidden');

            } catch (error) {
                statusEl.textContent = `エクスポートに失敗しました: ${error.message}`;
                statusEl.classList.add('error-message');
                statusEl.classList.remove('hidden');
                console.error('Export error:', error);
            }
        }

        /**
         * JSONファイルからデータ (チャットとGem) をインポートする
         */
        async function importData() {
            const fileInput = document.getElementById('import-file-input');
            const statusEl = document.getElementById('settings-status');
            statusEl.classList.add('hidden');

            if (fileInput.files.length === 0) {
                statusEl.textContent = 'インポートするファイルを選択してください。';
                statusEl.classList.add('error-message');
                statusEl.classList.remove('hidden');
                return;
            }

            const file = fileInput.files[0];
            const reader = new FileReader();

            reader.onload = async (event) => {
                try {
                    const importedData = JSON.parse(event.target.result);

                    if (!importedData || !importedData.chats || !importedData.gems) {
                        throw new Error('ファイルの構造が正しくありません。');
                    }

                    // チャットデータをインポート
                    for (const chat of importedData.chats) {
                        await putData(STORE_CHATS, chat);
                    }
                    // Gemデータをインポート
                    for (const gem of importedData.gems) {
                        await putData(STORE_GEMS, gem);
                    }

                    statusEl.textContent = `データのインポートが完了しました。チャット: ${importedData.chats.length}件、Gem: ${importedData.gems.length}件。`;
                    statusEl.classList.remove('error-message', 'hidden');
                    console.log('Import successful.');
                } catch (error) {
                    statusEl.textContent = `インポート処理中にエラーが発生しました: ${error.message}`;
                    statusEl.classList.add('error-message');
                    statusEl.classList.remove('hidden');
                    console.error('Import error:', error);
                }
            };

            reader.onerror = (error) => {
                statusEl.textContent = 'ファイルの読み込み中にエラーが発生しました。';
                statusEl.classList.add('error-message');
                statusEl.classList.remove('hidden');
                console.error('File read error:', error);
            };

            reader.readAsText(file);
        }

        // ===============================================
        // 10. 初期化
        // ===============================================
        
        // アプリケーション起動時の初期化
        (async function initialize() {
            try {
                await openDB();
                console.log('IndexedDB initialized successfully.');
            } catch (error) {
                alert(`アプリケーションの初期化に失敗しました。IndexedDBがサポートされていない可能性があります。${error.message}`);
                console.error('Initialization Error:', error);
            }
            switchTab('home'); // 初期表示はホームタブ
        })();

    </script>
</body>
</html>
